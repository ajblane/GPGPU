This directory contains scripts and programs to validate the hardware design
in cosimulation.  This works by executing a program in lock-step in both the 
Verilog simulator and C based emulator. It compares instruction side 
effects--register writebacks and memory stores--and flags an error if they don't 
match. Test programs can be real programs or random instruction sequences created 
by the generate_random utility. 

Randomized cosimulation is a common processor verification technique. Here are a 
few papers that describe it's application for some commercial processors:

* [Functional Verification of a Multiple-issue, Out-of-Order, Superscalar Alpha Processorâ€” The DEC Alpha 21264 Microprocessor](http://www.cs.clemson.edu/~mark/464/21264.verification.pdf) 
* [Functional Verification of the HP PA 8000 Processor](http://www.cs.clemson.edu/~mark/464/hp8000.verification.pdf) 
* [PicoJava II Verification Guide](http://www1.pldworld.com/@xilinx/html/pds/HDL/picoJava-II/docs/pj2-verif-guide.pdf)

# Executing Tests

Tests can be invoked directly like this:

    ./runtest.py <filename>

&lt;filename&gt; can an assembly file (.s), which will be assembled before 
execution, or a hex file, which will be executed directly. 

_The cosimulator only works in single-core configurations._

To debug issues, it is often desirable to see the actual instructions.  The 
listing file can be generated like this:

    usr/local/llvm-nyuzi/bin/llvm-objdump --disassemble WORK/test.elf > test.dis

And a trace can be generated by setting the SIMULATOR_DEBUG_ARGS environment 
variable:

    EMULATOR_DEBUG_ARGS=-v ./runtest.sh ...

### Simulator Random Seed

When simulation starts, the program will print:
<pre>
Random seed is 1405877782
</pre>

Verilator is a 2-state simulator. While a single bit in a standard Verilog 
simulator can have 4 states: 0, 1, X, and Z, Verilator only supports 0 and 1. 
As an alternative, Verilator allows setting random values for signals that 
are assigned X or Z.  This is a useful feature which allows catching failures 
that wouldn't be visible in a normal Verilog simulator because of inherent 
subtleties in the way the Verilog specification defines the behavior of X and Z. 
This paper http://www.arm.com/files/pdf/Verilog_X_Bugs.pdf gives a good 
description of these issues.

The RTL model will run slightly differently each time because all signals are 
not explicitly initialized at reset (SRAMs, for example).  To reproduce an issue
that is timing dependent, you can set the environment variable RANDSEED to the
value that caused the failure:

    RANDSEED=1419094753 ./runtest.sh cache_stress.s

# Generating New Random Test Program
 
Random tests are not checked into the tree. Use the generate.py script in the 
cosimulation directory to generate random test programs

    ./generate_random.py [-o output file] [-n number of instructions] [-m number of files]

Output will be written into the file 'random.s' by default.  

The -m file allows generating multiple test files.  For example:

    ./generate_random.py -m 100

These can then be run like this:

    ./runtest random*

## Instruction Selection for Random Program Generation
 
Using a completely unbiased random distribution of instructions doesn't give 
great coverage. For example:
* A branch will squash instructions in the pipeline.  If branches are issued 
too frequently, they will mask issues with instruction dependencies.
* If the full range of 32 registers are used as operands and destinations of 
instructions, it will be unlikely that there will be RAW dependencies between 
subsequent instructions.

For that reason, we use _constrained_ random instruction generation.  The 
distribution  of instructions is adjusted to give the best hardware coverage.  
The probabilities for instructions are currently hard-coded in generate.py.

Additional constraints are imposed to prevent improper program behavior, as 
follows:

### Branches

We want to avoid creating infinite loops. To ensure this, only forward branches
are generated. Additionally, we only allow a forward branch of up to 8
instructions to avoid skipping too much code.

### Memory accesses

We must avoid accessing invalid memory addresses, which would occur
if we used random register values for pointers. The generation program 
reserves three registers to act as memory pointers, which are guaranteed 
to be valid addresses.  s0/v0 points to the base of a shared region, which 
all strands may read from s1/v1 is the base of a private, per-thread region 
that all each thread may write to.  s2/v2 is pointer into the private region, 
computed from s1/v1. This is used to validate instruction RAW dependency 
checking for memory operations.

The test generator will choose random offsets for the memory access
instructions, which allows hitting different cache lines in that region
and generates a good mix of L1/L2 cache misses and hits. The alignment
of these 5 regions a multiple of L2 cache size so that aliasing of
the lines occurs.  This allows verifying L2 cache writebacks.

There is code in the Verilog testbench to copy all dirty L2 cache lines 
back to memory so it can be compared, as the random test program will 
not explicitly flush them. The C model does not emulate the caches.

_Currently, the testbench does not support a processor reading from 
addresses that another is writing to.  The emulator does not model the 
behavior of the store buffer, so we can't simulate this is a cycle accurate
manner yet._


# How it works
## Checking
 
When the verilog simulator is invoked with the +regtrace=1 flag, it will
print ASCII lines describing instruction side effects to stdout. These include:
* vector register writeback 
* scalar register writeback 
* memory store 

Each debug record includes the PC and thread of the instruction that caused it,
and register/address information specific to the instruction.

The emulator (tools/emulator) is a C program that simulates behavior of the 
instruction set, parses the textual output from the Verilog simulator.  It 
it possible to use something like VPI to directly call into the emulator, 
but text output is used instead for simplicity.

Each time the emulator parses one of these operations, it steps the strand
that is referenced in the instruction.  If instructions are executed
that don't have side effects (for example, a branch), it continues
stepping until it encounters one that does.  It then compares the side
effect of the instruction with the result from the Verilog simulator and
flags an error if there is a mismatch.

Some sequences of instructions may be order dependent. The emulator does 
not faithfully reproduce order of instruction issue. This mechanism handles 
that by allowing the Verilog simulator to control ordering of instruction 
issue, while still rigorously checking that the program state is accurate.

### Caveats
- The emulator does not currently model the behavior of the
store buffer. Since the store buffer affects visibility of writes to
other strands, this means the emulator can't accurately handle
reads/writes to the same cache lines from multiple threads. As such, the
random test generator currently reserves a separate write region for
each strand. The v2 architecture does not have this constraint.
- The random instruction generator does not generate floating point 
instructions, as there are still a fair number of subtle rounding
bugs in the floating point pipeline.

